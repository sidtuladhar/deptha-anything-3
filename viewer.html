<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Depth Anything v3 - Live Point Cloud Viewer</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family:
          -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        background: #1a1a1a;
        color: #ffffff;
        overflow: hidden;
      }

      #container {
        width: 100vw;
        height: 100vh;
        position: relative;
      }

      #canvas-container {
        width: 100%;
        height: 100%;
      }

      #info-panel {
        position: absolute;
        top: 20px;
        left: 20px;
        background: rgba(0, 0, 0, 0.7);
        padding: 20px;
        border-radius: 10px;
        backdrop-filter: blur(10px);
        min-width: 250px;
      }

      h1 {
        font-size: 18px;
        margin-bottom: 15px;
        color: #4caf50;
      }

      .status {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
        font-size: 14px;
      }

      .status-dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        margin-right: 10px;
        transition: background-color 0.3s;
      }

      .status-dot.connected {
        background-color: #4caf50;
        box-shadow: 0 0 10px #4caf50;
      }

      .status-dot.disconnected {
        background-color: #f44336;
      }

      .stat {
        font-size: 13px;
        margin: 5px 0;
        color: #aaa;
      }

      .stat strong {
        color: #fff;
      }

      #controls {
        position: absolute;
        bottom: 20px;
        left: 20px;
        background: rgba(0, 0, 0, 0.7);
        padding: 15px;
        border-radius: 10px;
        backdrop-filter: blur(10px);
        font-size: 12px;
        color: #aaa;
      }

      #controls div {
        margin: 5px 0;
      }

      .error-message {
        color: #f44336;
        margin-top: 10px;
        font-size: 12px;
      }

      #webcam-preview {
        position: absolute;
        top: 20px;
        right: 20px;
        width: 160px;
        height: 120px;
        border: 2px solid #4caf50;
        border-radius: 8px;
        display: none;
        transform: scaleX(-1);
      }

      button {
        background: #4caf50;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 14px;
        margin-top: 10px;
      }

      button:hover {
        background: #45a049;
      }

      button:disabled {
        background: #666;
        cursor: not-allowed;
      }
    </style>
  </head>
  <body>
    <div id="container">
      <div id="canvas-container"></div>

      <video id="webcam-preview" autoplay playsinline muted></video>

      <div id="info-panel">
        <h1>Live Point Cloud</h1>
        <div class="status">
          <div class="status-dot" id="status-dot"></div>
          <span id="status-text">Click Start to begin</span>
        </div>
        <button id="start-btn">Start Webcam</button>
        <div class="stat">Points: <strong id="point-count">0</strong></div>
        <div class="stat">FPS: <strong id="fps">0</strong></div>
        <div class="stat">Latency: <strong id="latency">0ms</strong></div>
        <div class="error-message" id="error" style="display: none"></div>
      </div>

      <div id="controls">
        <div><strong>Controls:</strong></div>
        <div>üñ±Ô∏è Left drag: Rotate</div>
        <div>üñ±Ô∏è Right drag: Pan</div>
        <div>üñ±Ô∏è Scroll: Zoom</div>
      </div>
    </div>

    <canvas id="frame-canvas" style="display: none;"></canvas>

    <!-- MessagePack for binary decoding -->
    <script src="https://cdn.jsdelivr.net/npm/msgpack-lite@0.1.26/dist/msgpack.min.js"></script>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";

      // WebSocket connection
      let ws = null;
      let reconnectInterval = null;

      // Webcam
      let stream = null;
      let videoElement = document.getElementById("webcam-preview");
      let canvas = document.getElementById("frame-canvas");
      let ctx = canvas.getContext("2d");
      let isStreaming = false;

      // Three.js setup
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x1a1a1a);

      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000,
      );
      camera.position.set(0, 0, 3);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      document
        .getElementById("canvas-container")
        .appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;

      // Add grid helper
      const gridHelper = new THREE.GridHelper(10, 10, 0x444444, 0x222222);
      scene.add(gridHelper);

      // Add axes helper
      const axesHelper = new THREE.AxesHelper(1);
      scene.add(axesHelper);

      // Point cloud
      let pointCloud = null;
      let geometry = null;

      // Stats
      let frameCount = 0;
      let lastTime = Date.now();
      let fps = 0;

      // UI elements
      const statusDot = document.getElementById("status-dot");
      const statusText = document.getElementById("status-text");
      const pointCountEl = document.getElementById("point-count");
      const fpsEl = document.getElementById("fps");
      const latencyEl = document.getElementById("latency");
      const errorEl = document.getElementById("error");
      const startBtn = document.getElementById("start-btn");

      function updateStatus(connected, message) {
        if (connected) {
          statusDot.classList.add("connected");
          statusDot.classList.remove("disconnected");
          statusText.textContent = "Connected";
          errorEl.style.display = "none";
        } else {
          statusDot.classList.remove("connected");
          statusDot.classList.add("disconnected");
          statusText.textContent = message || "Disconnected";
          if (message && message.includes("Error")) {
            errorEl.textContent = message;
            errorEl.style.display = "block";
          }
        }
      }

      async function startWebcam() {
        try {
          stream = await navigator.mediaDevices.getUserMedia({
            video: { width: 320, height: 240 },
          });
          videoElement.srcObject = stream;
          videoElement.style.display = "block";

          // Wait for video to be ready
          await new Promise((resolve) => {
            videoElement.onloadedmetadata = () => {
              videoElement.play();
              resolve();
            };
          });

          startBtn.textContent = "Stop";
          startBtn.disabled = false;
          return true;
        } catch (error) {
          console.error("Webcam error:", error);
          updateStatus(false, "Webcam access denied");
          startBtn.disabled = false;
          return false;
        }
      }

      function stopWebcam() {
        if (stream) {
          stream.getTracks().forEach((track) => track.stop());
          videoElement.srcObject = null;
          videoElement.style.display = "none";
          stream = null;
        }
        isStreaming = false;
        startBtn.textContent = "Start Webcam";

        // Clear reconnect interval when stopping
        if (reconnectInterval) {
          clearInterval(reconnectInterval);
          reconnectInterval = null;
        }
      }

      function connectWebSocket() {
        try {
          // Auto-detect WebSocket URL based on current page location
          const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
          const wsUrl = `${protocol}//${window.location.host}/ws`;

          console.log("Connecting to:", wsUrl);
          ws = new WebSocket(wsUrl);

          ws.onopen = () => {
            console.log("WebSocket connected");
            updateStatus(true);
            if (reconnectInterval) {
              clearInterval(reconnectInterval);
              reconnectInterval = null;
            }
            startFrameCapture();
          };

          ws.onmessage = (event) => {
            try {
              let data;

              // Handle both binary (msgpack) and text (JSON) messages
              if (event.data instanceof Blob) {
                // Binary message - convert Blob to ArrayBuffer
                event.data.arrayBuffer().then((buffer) => {
                  try {
                    data = msgpack.decode(new Uint8Array(buffer));
                    processPointCloudData(data);
                  } catch (e) {
                    console.error("Error decoding Blob:", e);
                  }
                });
                return;
              } else if (event.data instanceof ArrayBuffer) {
                // Binary message - decode msgpack
                data = msgpack.decode(new Uint8Array(event.data));
              } else {
                // Text message - parse JSON (fallback)
                data = JSON.parse(event.data);
              }

              processPointCloudData(data);
            } catch (e) {
              console.error("Error parsing message:", e);
            }
          };

          function processPointCloudData(data) {
            if (data.type === "pointcloud") {
              updatePointCloud(data);

              // Update stats
              frameCount++;
              const now = Date.now();
              if (now - lastTime >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastTime = now;
                fpsEl.textContent = fps;
              }

              // Ready for next frame
              isProcessing = false;
            }
          }

          ws.onerror = (error) => {
            console.error("WebSocket error:", error);
            updateStatus(false, "Connection Error - Retrying...");
          };

          ws.onclose = () => {
            console.log("WebSocket disconnected");
            updateStatus(false, "Disconnected - Retrying...");

            // Only retry if webcam is still active
            if (stream) {
              if (!reconnectInterval) {
                reconnectInterval = setInterval(() => {
                  console.log("Attempting to reconnect...");
                  connectWebSocket();
                }, 2000);
              }
            }
          };
        } catch (e) {
          console.error("Failed to create WebSocket:", e);
          updateStatus(false, "Error: " + e.message);
        }
      }

      let isProcessing = false;

      function startFrameCapture() {
        if (!stream || !ws || ws.readyState !== WebSocket.OPEN) return;

        isStreaming = true;

        function captureFrame() {
          if (!isStreaming || isProcessing) return;

          isProcessing = true;

          // Set canvas size to match video
          canvas.width = videoElement.videoWidth;
          canvas.height = videoElement.videoHeight;

          // Draw video frame to canvas
          ctx.drawImage(videoElement, 0, 0);

          // Convert to base64
          const imageData = canvas.toDataURL("image/jpeg", 0.8);
          const base64Data = imageData.split(",")[1];

          // Send to server
          const message = JSON.stringify({
            type: "frame",
            image: base64Data,
          });

          if (ws.readyState === WebSocket.OPEN) {
            ws.send(message);
          }

          // Will be triggered after receiving response
        }

        // Trigger frame capture
        setInterval(() => {
          if (!isProcessing && isStreaming) {
            captureFrame();
          }
        }, 16); // Check every frame (60fps)
      }

      function updatePointCloud(data) {
        const startTime = Date.now();

        // Remove old point cloud
        if (pointCloud) {
          scene.remove(pointCloud);
          if (geometry) geometry.dispose();
        }

        let positions, colorArray;

        // Check if data is in binary format (ArrayBuffer/Uint8Array) or array format
        if (data.points instanceof Uint8Array || data.points instanceof ArrayBuffer) {
          // Binary format - convert bytes to Float32Array
          const pointsBuffer = data.points instanceof Uint8Array ? data.points : new Uint8Array(data.points);
          const colorsBuffer = data.colors instanceof Uint8Array ? data.colors : new Uint8Array(data.colors);

          positions = new Float32Array(pointsBuffer.buffer, pointsBuffer.byteOffset, pointsBuffer.byteLength / 4);

          // Colors are uint8, convert to float32 and normalize
          const numPoints = positions.length / 3;
          colorArray = new Float32Array(numPoints * 3);
          for (let i = 0; i < numPoints * 3; i++) {
            colorArray[i] = colorsBuffer[i] / 255;
          }

          // Flip Z axis for depth
          for (let i = 0; i < numPoints; i++) {
            positions[i * 3 + 2] = -positions[i * 3 + 2];
          }
        } else {
          // Array format (legacy JSON) - convert to Float32Array
          const points = data.points;
          const colors = data.colors;

          if (!points || points.length === 0) {
            return;
          }

          positions = new Float32Array(points.length * 3);
          colorArray = new Float32Array(colors.length * 3);

          for (let i = 0; i < points.length; i++) {
            positions[i * 3] = points[i][0];
            positions[i * 3 + 1] = points[i][1];
            positions[i * 3 + 2] = -points[i][2]; // Flip Z for depth
          }

          for (let i = 0; i < colors.length; i++) {
            colorArray[i * 3] = colors[i][0] / 255;
            colorArray[i * 3 + 1] = colors[i][1] / 255;
            colorArray[i * 3 + 2] = colors[i][2] / 255;
          }
        }

        // Create new geometry
        geometry = new THREE.BufferGeometry();

        geometry.setAttribute(
          "position",
          new THREE.BufferAttribute(positions, 3),
        );
        geometry.setAttribute(
          "color",
          new THREE.BufferAttribute(colorArray, 3),
        );

        // Create material
        const material = new THREE.PointsMaterial({
          size: 0.003,
          vertexColors: true,
          sizeAttenuation: true,
        });

        // Create point cloud
        pointCloud = new THREE.Points(geometry, material);
        scene.add(pointCloud);

        // Update UI
        pointCountEl.textContent = data.num_points.toLocaleString();

        const latency = Date.now() - startTime;
        latencyEl.textContent = latency + "ms";
      }

      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }

      // Handle window resize
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // Event listeners
      startBtn.addEventListener("click", async () => {
        if (!isStreaming) {
          startBtn.disabled = true;
          startBtn.textContent = "Starting...";
          const webcamOk = await startWebcam();
          if (webcamOk) {
            connectWebSocket();
          }
        } else {
          stopWebcam();
          if (ws) ws.close();
        }
      });

      // Start
      animate();
    </script>
  </body>
</html>
